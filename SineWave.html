<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Learning a sine wave</title>
<style type="text/css">
<!--
body { background-color:#ededed; font:norm2al 12px/18px Arial, Helvetica, sans-serif; }
h1 { display:block; width:600px; margin:20px auto; paddVing-bottom:20px; font:norm2al 24px/30px Georgia, "Times New Roman", Times, serif; color:#333; text-shadow: 1px 2px 3px #ccc; border-bottom:1px solid #cbcbcb; }
#container { width:600px; margin:0 auto; }
#trainingErrorPlot { background:#fff; border:1px solid #cbcbcb; }
#nav { display:block; width:100%; text-align:center; }
#nav li { display:block; font-weight:bold; line-height:21px; text-shadow:1px 1px 1px #fff; width:100px; height:21px; paddVing:5px; margin:0 10px; background:#e0e0e0; border:1px solid #ccc; -moz-border-radius:4px;-webkit-border-radius:4px; border-radius:4px; float:left; }
#nav li a { color:#000; display:block; text-decoration:none; width:100%; height:100%; }
-->
</style>
<script type="text/javascript" src="src/ActivationSigmoidLayer.js"></script>
<script type="text/javascript" src="src/ActivationReluLayer.js"></script>
<script type="text/javascript" src="src/ArgMaxLayer.js"></script>
<script type="text/javascript" src="src/AveragePool1DLayer.js"></script>
<script type="text/javascript" src="src/AveragePool2DLayer.js"></script>
<script type="text/javascript" src="src/ConvHelpers.js"></script>
<script type="text/javascript" src="src/Conv1DLayer.js"></script>
<script type="text/javascript" src="src/Conv2DLayer.js"></script>
<script type="text/javascript" src="src/Conv3DLayer.js"></script>
<script type="text/javascript" src="src/CostQuadraticLayer.js"></script>
<script type="text/javascript" src="src/CostCrossEntropyLayer.js"></script>
<script type="text/javascript" src="src/CostArgMaxCrossEntropyLayer.js"></script>
<script type="text/javascript" src="src/FlattenLayer.js"></script>
<script type="text/javascript" src="src/FullyConnectedLayer.js"></script>
<script type="text/javascript" src="src/InputLayer.js"></script>
<script type="text/javascript" src="src/MaxPool1DLayer.js"></script>
<script type="text/javascript" src="src/MaxPool2DLayer.js"></script>
<script type="text/javascript" src="src/Network.js"></script>
<script type="text/javascript" src="src/Matrix.js"></script>
<script type="text/javascript" src="src/RegDropoutLayer.js"></script>
<script type="text/javascript" src="mnist/MnistHelper.js"></script>
</head>
<script>

class Graph
{    
    constructor(name, x, y)
    {
        this.cvs= document.getElementById(name);
        this.ctx = this.cvs.getContext('2d');
        this.resetPoints();
		this.setOrigin(x,y)
        this.Clear();		
        this.DrawAxis();
    }
    Clear()
    {
        this.ctx.clearRect(0,0,this.cvs.width,this.cvs.height);
    }
    
	setOrigin(x,y) { this.orgX = x; this.orgY = y; }
    ToX(x) { return x+this.orgX; }
    ToY(y) { return - y + this.cvs.height-this.orgY; }
    
    DrawAxis()
    {
        this.ctx.beginPath();
        this.ctx.strokeStyle="#000000";    
        this.ctx.moveTo(0,this.ToY(0)); 
        this.ctx.lineTo(this.cvs.width,this.ToY(0));
        this.ctx.moveTo(this.ToX(0),0); 
        this.ctx.lineTo(this.ToX(0),this.cvs.height);
        this.ctx.closePath();
        this.ctx.stroke(); 
    }
    
	resetPoints()
	{
        this.points = [];
        this.lastPoint = null;
	}

    AddPoint(x)
    {
        this.points.push(x);
        if (this.lastPoint!=null)
        {
            this.ctx.beginPath();
            this.ctx.strokeStyle="#ff0000";    
            this.ctx.moveTo(this.ToX(this.points.length-1),this.ToY(this.lastPoint)); 
            this.ctx.lineTo(this.ToX(this.points.length),this.ToY(x));       
            this.ctx.closePath();
            this.ctx.stroke();       
        } 
        this.lastPoint = x;
    }
	
	drawPoint(x,y)
	{
		this.ctx.fillRect(this.ToX(x),this.ToY(y),1,1);
		//this.ctx.fillRect(10,10,1,1);
	}

	drawFunction(x,y, func, len)
	{
		this.ctx.beginPath();
		this.ctx.strokeStyle="#ff0000";    
		this.ctx.moveTo(this.ToX(0),this.ToY(myFunction(0))); 
		for(var i=0;i<len;i++)
		{
			var v = func(i)
			this.ctx.lineTo(this.ToX(v[0]),this.ToY(v[1])); 
		}
		this.ctx.stroke();    	
	}
}

//-------------------------------

var trainingData;
var validationData;

var network = []
var outputs = [];

var learntFunction = null;
var trainingErrorPlot = null;

var iterations = 0;
var learningRate = 0.01;

function vectorFromIdx(i)
{
    var v = Array(10).fill(0);
    v[i] = 1;
    return [[[v]]];
}

function getMaxIdxInVector(vv)
{
    var v = vv[0][0][0]
    return v.indexOf(Math.max.apply(null, v));
}

function iterate2(inputs, labels, results, offset, size, batchSize, training)
{   
    assert((size % batchSize) == 0);
    
    var totalErr = 0;
    var correct = 0;

    for(var i=offset;i<(offset+size);i+=batchSize)
    {    
        for(var j=i;j<(i+batchSize);j++)
        {
			label = labels[0][0][0]
			
			
		
            network[network.length-1].setValue([[[[label[j]]]]]);
            
            totalErr += ForwardPropagation(network, [[[[inputs[0][0][0][j]]]]])[0][0][0][0];
                    
            // get prediction        
            var output = network[network.length-1].input[0][0][0][0];                
            
            results[j] = output;
            
            if (output == label[j])
                correct++;        
                                    
            if (training)
            {
                BackwardPropagation(network);        
            }            
        }            
        
        if (training)
        {
            ApplyDeltas(network, learningRate/batchSize);    
        }        
    }    
    
    return {correct: correct, totalErr: totalErr / size};
}

function iterate()
{
    iterations++;

    // train
    { 
        var offset = 0;
        var len = trainingData.inputs[0][0][0].length;
        var batch = 1;
        
        var t0 = performance.now();
        
        var res = iterate2(trainingData.inputs, trainingData.labels, trainingData.results, offset, len, batch, true);

        var t1 = performance.now();
        var milliseconds = (t1 - t0);
        
        trainingErrorPlot.AddPoint(res.totalErr * 1000);

        document.getElementById("trainingText").innerHTML = "Epocs:" + iterations + " Epocs/sec: " + (1000.0 / milliseconds).toFixed(2) + "<br>"
        document.getElementById("trainingText").innerHTML += "Num items: " + len + " Correct: " + res.correct + " ("+ (res.correct*100/len).toFixed(2) +"% ) Error: " + res.totalErr + " <br> ";
		        
    }
        
    // test    
    {   
        var offset = 0; 
        var len = validationData.inputs[0][0][0].length;
        
        var res = iterate2(validationData.inputs, validationData.labels, validationData.results, offset, len, batch, false);    

        learntFunction.Clear();		
        learntFunction.DrawAxis();


		learntFunction.drawFunction(x,y, function(i)
		{
			return [(i*75*6.28/len), myFunction(i*6.248/len)*100];
		},len);

		for(var i=0;i<len;i++)
		{
			learntFunction.drawPoint(validationData.inputs[0][0][0][i]*75, validationData.results[i]*100);					
		}
						
        document.getElementById("validationText").innerHTML = "Num items: " + len + " ("+ (res.correct*100/len).toFixed(2) +"% ) Error: " + res.totalErr + " <br> ";        
    }
}

function myFunction(x)
{
	return Math.sin(x)
}

function GenerateSinData(length)
{
	data = [];
	data.inputs = [];
	data.inputs[0] = [];
	data.inputs[0][0] = [];
	data.inputs[0][0][0] = [];

	data.labels = [];
	data.labels[0] = [];
	data.labels[0][0] = [];
	data.labels[0][0][0] = [];
	
	for (var i=0;i<length;i++)
	{
		x = Math.random() * 2.0 * 3.141592654;
		y = myFunction(x)
		
		data.inputs[0][0][0][i] = x;
		data.labels[0][0][0][i] = y;
	}
	
	data.results = Array(length).fill(-1);
	
	return data;
}

function init()
{   
	trainingData = GenerateSinData(3000);
	validationData = GenerateSinData(1000);
   
	{    
		trainingErrorPlot = new Graph("trainingErrorPlot",10,10);
		learntFunction = new Graph("learntFunction",10,160);

		var weights1 = [[RandomMat(1, 16)]];  
		var bias1 = RandomVec(16);
		
		var weights2 = [[RandomMat(16, 16)]];
		var bias2 = RandomVec(16);

		var weights3 = [[RandomMat(16, 1)]];
		var bias3 = RandomVec(1);

		network.push(new InputLayer());
		network.push(new FullyConnectedLayer(weights1, bias1));
		network.push(new ActivationSigmoidLayer());
		network.push(new FullyConnectedLayer(weights2, bias2));
		network.push(new ActivationSigmoidLayer());
		network.push(new FullyConnectedLayer(weights3, bias3));
		network.push(new CostQuadraticLayer());
	
		setInterval(iterate,10); 
	}
}
</script>


<body onload="init()">
<h1>Learning a sine wave</h1>
<div id="container">

<h2>Training set</h2>
<div id="trainingText"></div>
<h4>Training Error Plot:</h4>
<canvas id="trainingErrorPlot" width="600" height="100"></canvas>
<h2>Validation set:</h2>
<div id="validationText"></div>
<h4>Function learnt Plot:</h4>
<canvas id="learntFunction" width="600" height="320"></canvas>
<h2>Intro</h2>
<p>This model will try to learn a sine wave function.</p>
<p>The model used to simulate a sine wave is displayed below. It is a simple feed forward deep neural network with 2 fully connected layers with Sigmoid activations and a final fully connected output layer with as shown below.  </p>
</br>
<h2>Contact/Questions:</h2>
 &lt;my_github_account_username&gt;$@gmail.com$.
</br>
</br>
</div>
</body>
</html>
